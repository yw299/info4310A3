<!DOCTYPE html>
<head>

  <title>Homework 3</title>
  <meta charset="utf-8" />
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>

  <style>

  /* #container {
    display: flex;
  } */

  #sidebar {
    display: flex;
  }

  .sidediv {
    display: flex;
    flex-direction: column;
    margin: 10px;
  }

  select {
        display: block;
        background-color: #E5E5E5;
        border-color: #F9B806;
        font-size:20px;
        border-radius: 5px;
        border-width: 5px;
        /* margin:20px; */
        padding:10px;
    }

  #button{
        margin-top: -20px;
        margin-left:40px;
    }
  .neighborhood {
    fill: #f9f9f9;
    stroke: #bdbdbd;
    stroke-width: 1px;
  }

  rect.handle {
      display: none;
  }
  rect.overlay {
      display: none;
  }

  .txts {
    font-family: Arial, sans-serif;
  }

  </style>

</head>

<body>

  <h1>Pittsburgh Restaurant Reviews</h1>
<svg id="canvas" width="1200" height="900">
  <g id="map" width="1200" height="900"></g>
  <g id="minimap" width="300" height="300" transform="translate(899,1)">
        <rect x="0" y="0" width="300" height="300" stroke="black" stroke-width="1" fill="white" opacity="1"/>
  </g>
</svg>

    <div id="sidebar">


    <div id="filters" class="sidediv">
      <h3>Choose a Restuarant Category</h3>

      <span class="check"><input type="checkbox" class="checkbox" name="active" value="active">Active</span>
      <span class="check"><input type="checkbox" class="checkbox" name="arts" value="arts">Art</span>
      <span class="check"><input type="checkbox" class="checkbox" name="bakeries" value="bakeries">Bakeries</span>
      <span class="check"><input type="checkbox" class="checkbox" name="cafes" value="cafes">Cafes</span>
      <span class="check"><input type="checkbox" class="checkbox" name="chinese" value="chinese">Chinese</span>
      <span class="check"><input type="checkbox" class="checkbox" name="coffee" value="coffee">Coffee</span>
      <span class="check"><input type="checkbox" class="checkbox" name="donuts" value="donuts">Donuts</span>
      <span class="check"><input type="checkbox" class="checkbox" name="ethnicmarkets" value="ethnicmarkets">Ethnicmarkets</span>
      <span class="check"><input type="checkbox" class="checkbox" name="french" value="french">French</span>
      <span class="check"><input type="checkbox" class="checkbox" name="indpak" value="indpak">Indpak</span>
      <span class="check"><input type="checkbox" class="checkbox" name="italian" value="italian">Italian</span>
      <span class="check"><input type="checkbox" class="checkbox" name="japanese" value="japanese">Japanese</span>
      <span class="check"><input type="checkbox" class="checkbox" name="mexican" value="mexican">Mexican</span>
      <span class="check"><input type="checkbox" class="checkbox" name="newamerican" value="newamerican">NewAmerican</span>
      <span class="check"><input type="checkbox" class="checkbox" name="nightlife" value="nightlife">NightLife</span>
      <span class="check"><input type="checkbox" class="checkbox" name="pizza" value="pizza">Pizza</span>
      <span class="check"><input type="checkbox" class="checkbox" name="restaurant" value="restaurant">Resturant</span>
      <span class="check"><input type="checkbox" class="checkbox" name="sandwiches" value="sandwiches">Sandwiches</span>
      <span class="check"><input type="checkbox" class="checkbox" name="shopping" value="shopping">Shopping</span>
      <span class="check"><input type="checkbox" class="checkbox" name="sushi" value="sushi">Sushi</span>
      <span class="check"><input type="checkbox" class="checkbox" name="thai" value="thai">Thai</span>
      <span class="check"><input type="checkbox" class="checkbox" name="vietnamese" value="vietnamese">Vietnamese</span>


      <h3>Choose Popular Neighborhood</h3>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="Downtown" value="Downtown">Downtown</span>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="Lawrenceville" value="Lawrenceville">Lawrenceville</span>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="Oakland" value="Oakland">Oakland</span>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="South Side" value="South Side">South Side</span>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="Squirrel Hill" value="Squirrel Hill">Squirrel Hill</span>
      <span class="check"><input type="checkbox" class="neighborhoodcheckbox" name="Strip District" value="Strip District">Strip District</span>


      <button type="button" name="button">Filter</button>
      <button type="button" name="button" class="clear">Clear</button>

    </div>

  </div>


  <script id="code">

    // Map & Dimensions
    const map = d3.select("svg g#map");
    const mapWidth = map.attr("width");
    const mapHeight = map.attr("height");
    const chartArea = map.append("g");

    // make the minimap
    const minimap = d3.select("svg g#minimap");
    const minimapWidth = minimap.attr("width");
    const minimapHeight = minimap.attr("height");
    const minimapArea = minimap.append("g")
                               // .attr("transform","translate("+minimapMargin.left+","+minimapMargin.top+")")
                               .attr("opacity", 0.5);



   map.append("defs").append("clipPath")
                     .attr("id","chartClip")
                     .append("rect").attr("x",0)
                                    .attr("y",0)
                                    .attr("width",mapWidth)
                                    .attr("height",mapHeight);
    const menu = d3.select("#menu");


    map.attr("clip-path","url(#chartClip)");


    minimap.append("defs").append("clipPath")
                      .attr("id","minichartClip")
                      .append("rect").attr("x",0)
                                     .attr("y",0)
                                     .attr("width",minimapWidth)
                                     .attr("height",minimapHeight);

     minimap.attr("clip-path","url(#minichartClip)");
    // RequestData function
    const requestData = async function() {


      // Loading data
      const pittsData = await d3.json("pittsburgh_neighborhoods.json");
      const yelpData = await d3.csv("yelp_pittsburgh.csv");


      // make an interactive "surface" at the top of the plot area
     chartArea.append("rect").attr("x",0).attr("y",0)
                       .attr("width",mapWidth).attr("height",mapHeight)
                       .attr("fill","none")
                       .style("pointer-events","all");

      // Map Projection
      var pitts = topojson.feature(pittsData, pittsData.objects.Neighborhoods_);
      var pittsProjection = d3.geoMercator().fitSize([900, mapHeight], pitts);
      var pittsPath = d3.geoPath().projection(pittsProjection);

      // MiniMap Projection
      var pitts_mini = topojson.feature(pittsData, pittsData.objects.Neighborhoods_);
      var pittsProjection_mini = d3.geoMercator().fitSize([minimapWidth, minimapHeight], pitts_mini);
      var pittsPath_mini = d3.geoPath().projection(pittsProjection_mini);


      // Restaurant position
      yelpData.forEach( d => {
        d.Position = pittsProjection( [d.longitude, d.latitude]);
      });


      console.log(yelpData);

      //minimap Restaurant position
      yelpData.forEach( d => {
        d.mini_Position = pittsProjection_mini( [d.longitude, d.latitude]);
      });

      console.log(yelpData);

      // Drawing Map Projection
      chartArea.selectAll("path.neighborhood").data(pitts.features)
          .join("path")
          .attr("class", "neighborhood")
          .attr("d", pittsPath);


      // Drawing MiniMap Projection
      minimapArea.selectAll("path.neighborhood").data(pitts.features)
          .join("path")
          .attr("class", "neighborhood")
          .attr("d", pittsPath_mini);


      // Drawing Resturant Positions
      let circles=chartArea.selectAll("circle").data(yelpData)
        .join("circle")
        .attr("r", 5)
        .attr("fill", "orange")
        .attr("opacity", 0.5)
        .attr("cx", d => d.Position[0])
        .attr("cy", d => d.Position[1])
        .on("mouseenter", function() {

          let dot = d3.select(this);

          txt.text(dot.datum().name);
          var category = (dot.datum().category).toUpperCase();;
          txt2.text(category);
          if (dot.datum().rating == 1) {
            txt3.text("★");
          } else if (dot.datum().rating == 2) {
            txt3.text("★ ★");
          } else if (dot.datum().rating == 3) {
            txt3.text("★ ★ ★");
          } else if (dot.datum().rating == 3.5) {
            txt3.text("★ ★ ★ ½");
          } else if (dot.datum().rating == 4) {
            txt3.text("★ ★ ★ ★");
          } else if (dot.datum().rating == 4.5) {
            txt3.text("★ ★ ★ ★ ½");
          } else {
            txt3.text("★ ★ ★ ★ ★");
          };

          tooltip.style("visibility","visible")
            .attr("transform", "translate(" + (dot.datum().Position[0] + 8) +", " + (dot.datum().Position[1] + 9) +")");

        })
        .on("mouseout", function() {

          let dot = d3.select(this);

          tooltip.style("visibility","hidden");

        });


        // Tooltip
        let tooltipWidth = 300;
        let tooltipHeight = 100;

        let tooltip = chartArea.append("g")
          .attr("class", "tooltip")
          .attr("visibility", "hidden");

        let hover = tooltip.append("rect")
          .attr("fill", "#0f133b")
          .attr("opacity", 1)
          .attr("rx", 8)
          .attr("width", tooltipWidth)
          .attr("height", tooltipHeight);

        let txt = tooltip.append("text")
          .attr("class", "txts")
          .attr("font-weight", "900")
          .attr("fill", "#ffffff")
          .attr("text-anchor","middle")
          .attr("alignment-baseline","central");

        let txt2 = tooltip.append("text")
          .attr("class", "txts")
          .attr("fill", "#ffffff")
          .attr("text-anchor","middle")
          .attr("alignment-baseline","central");

        let txt3 = tooltip.append("text")
          .attr("class", "txts")
          .attr("text-anchor","middle")
          .attr("fill", "#ffc20a")
          .attr("alignment-baseline","central");



    // Drawing Resturant Positions on minimap
    let circles_mini=minimapArea.selectAll("circle").data(yelpData)
      .join("circle")
      .attr("r", 2)
      .attr("fill", "orange")
      .attr("opacity", 0.5)
      .attr("cx", d => d.mini_Position[0])
      .attr("cy", d => d.mini_Position[1]);



        //zoom
        let zoomExtent = [[0,0],[mapWidth,mapHeight]];
        let translateExtent = [[-100,-100],[1000,1000]];
        var plotZoom = d3.zoom()
                       .extent(zoomExtent)
                       .translateExtent(translateExtent)
                       .scaleExtent([1,8])
                       .on("zoom", plotZoomed);



     // then add the zoom handler
    map.call(plotZoom);





    // add a brush
    let brushGroup = minimapArea.append("g").attr("class","brush");
    let brush = d3.brush()
        .extent([[0,0], [minimapWidth,minimapHeight]])
        //.on("start", startbrush)
        .on("brush", brushed)
        //.on("end", endbrush);
    brushGroup.call(brush)





           function plotZoomed( evt ) {

          let transform = evt.transform;

          chartArea.attr("transform", transform);
          function getScreenCoords(x, y,transform) { 
              var xn = (x-transform.x)/transform.k ; 
               var yn = (y-transform.y)/transform.k ; 
                return [xn, yn]; }

                 // console.log(evt)
            let upperleft=pittsProjection.invert(getScreenCoords(0,0,evt.transform))
            let lowerright=pittsProjection.invert(getScreenCoords(mapWidth,mapHeight,evt.transform))
            minimapBounds = [pittsProjection_mini(upperleft), pittsProjection_mini(lowerright)]
            // console.log(minimapBounds)
//sos: transform issue
          // // adjust circle size too
          circles.attr("r", 6 / transform.k);

          // unadjust hover box
          hover.attr("width", tooltipWidth / transform.k);
          hover.attr("height", tooltipHeight / transform.k);
          hover.attr("rx", 8 / transform.k)

          // unadjust hover box text
          txt.attr("font-size", 14 / transform.k)
            .attr("x", tooltipWidth / 2.0 / transform.k)
            .attr("y", 25 / transform.k);

          txt2.attr("font-size", 12 / transform.k)
            .attr("x", tooltipWidth / 2.0 / transform.k)
            .attr("y", 50 / transform.k);

          txt3.attr("font-size", 14 / transform.k)
            .attr("x", tooltipWidth / 2.0 / transform.k)
            .attr("y", 75 / transform.k);





      brushGroup.call(brush.move, minimapBounds)


        }



        function brushed( {sourceEvent, selection} ) {

          // // this will go into an infinite loop if you don't catch the things triggered by the zoom
          if (sourceEvent === undefined) {
            return;
          }
          //
          let transform = d3.zoomTransform(chartArea.node());
          // console.log(transform)

        // console.log(selection)
                let upperleft=pittsProjection_mini.invert([selection[0][0],selection[0][1]])
                let lowerright=pittsProjection_mini.invert([selection[1][0],selection[1][1]])
                // console.log(upperleft)
                // console.log(lowerright)
                function getScreenCoords(x, y,transform) { 
                    var xn = (x-transform.x)/transform.k ; 
                     var yn = (y-transform.y)/transform.k ; 
                      return [xn, yn]; }


           transform.x = selection[0][0]-(pittsProjection(upperleft)[0])*transform.k;
           transform.y = selection[0][1]-(pittsProjection(upperleft)[1])*transform.k;

          //
        map.call(plotZoom.transform, transform);
        }


        map.call(plotZoom.transform, d3.zoomIdentity);




        //checkbox filtering by category
        //by default if boxes and boxes_neighborhood length  === 0, then newdata = yelpData

        d3.select("button").on("click",function(){
            var checked=[];
            var checked_neighborhood=[]
            var boxes = d3.selectAll("input.checkbox:checked");
            var boxes_neighborhood = d3.selectAll("input.neighborhoodcheckbox:checked");
            boxes.each(function(){
              checked.push(this.value)
            });
            boxes_neighborhood.each(function(){
              checked_neighborhood.push(this.value)
            });
            console.log(checked)
            console.log(checked_neighborhood)
            //update new data
            // newdata = []
            newdata = yelpData.filter((d)=>{
              let passed_category_filter = false;
              let passed_neighborhood_filter = false;



              if (checked.length === 0){
                passed_category_filter = true;
              } else {
                checked.forEach((category, i) => {
                  passed_category_filter = passed_category_filter || d['category']===category
                });

              }

              if (checked_neighborhood.length ===0) {
                passed_neighborhood_filter = true;
              } else {
                checked_neighborhood.forEach((neighborhood, i) => {
                  passed_neighborhood_filter = passed_neighborhood_filter || d['neighborhood']===neighborhood
                });

              }


            return passed_category_filter && passed_neighborhood_filter;
            })
              updateMap(newdata)
              updateMiniMap(newdata)
              });

              //uncheck boxes
              function uncheckAll(){
                d3.selectAll('input').property('checked',false);
                d3.select("#menu").remove()
              };


        //clear checkbox
        d3.select(".clear").on("click",function(){
          uncheckAll()
          updateMap(yelpData)
          updateMiniMap(yelpData)
        });

              //update map function
              function updateMap(data){
                var pitts = topojson.feature(pittsData, pittsData.objects.Neighborhoods_);
                var pittsProjection = d3.geoMercator().fitSize([mapWidth, mapHeight], pitts);
                var pittsPath = d3.geoPath().projection(pittsProjection);

                //update map
                data.forEach( d => {
                  d.Position = pittsProjection( [d.longitude, d.latitude]);
                });

                let circles = chartArea.selectAll("circle").data(data)
                  .join("circle")
                  .attr("r", 5)
                  .attr("fill", "orange")
                  .attr("opacity", 0.5)
                  .attr("cx", d => d.Position[0])
                  .attr("cy", d => d.Position[1]);


              };


              function updateMiniMap(data){
                var pitts_mini = topojson.feature(pittsData, pittsData.objects.Neighborhoods_);
                var pittsProjection_mini = d3.geoMercator().fitSize([minimapWidth, minimapHeight], pitts_mini);
                var pittsPath_mini = d3.geoPath().projection(pittsProjection_mini);

                data.forEach( d => {
                  d.mini_Position = pittsProjection_mini( [d.longitude, d.latitude]);
                });


                let circles_mini=minimapArea.selectAll("circle").data(data)
                  .join("circle")
                  .attr("r", 2)
                  .attr("fill", "orange")
                  .attr("opacity", 0.5)
                  .attr("cx", d => d.mini_Position[0])
                  .attr("cy", d => d.mini_Position[1]);
              };

  };



    // RequestData call

    requestData();

  </script>

</body>

</html>
